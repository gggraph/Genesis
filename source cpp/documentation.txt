-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
																				TO DO	
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
* RSA SIGNATURE AND VERIFICATION INCOMPLET
* RENOMMER FONCTION ADD UTXO / GET UTXO .... 
* HASH TARGET / POW / ARITH256 NOT IMPLEMENTED
* PTX NODE VALIDATION
* BLOCK RETROGRADING INCOMPLETE ( REVIEW CONSENSUS )
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
																		How works file structure ?
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_

	[1] The blockchain files 
	/blockchain
		/blocksptr
		/0
		/1
		/2

	Blockchain files are series of files containing a limited number of blocks determined by MAX_FILE_SIZE ( actually UINT32 max value ).
	Blockchain files are contained in /blockchain folder. It contains at least two file. the "blocksptr" file wich deliver file pointer and bloc pointers in ascending
	order. Then all blockchain files names respectively, 0,1,2,3 ... etc. 
	The blocksptr is read in memory at start. A specific number of block can be read in memory determined by the user (refreshed at every official update).
	
	[2] The UTXO files 
	/utxos
		/tmp
		/0
		/1
		/2
	*see "How forking block are treat? How virtualisation works?" documentation.

	[3] The Smart Contract files
	/sc
		/0ad6fdnc0adletca0
	all smart contract storage file name correspond to the sha256 of (block index + byteoffset of proper CST).
	*see How contract works? And how it is read ? 

	[4] The Temporary storage
	/tmp
		/afe89fsnlvms256d 

	The temp storage contains all net received files (which are often named as lasthash block, or tx checksum etc. ). 
	It contains also mined block.

	[5] The Forks storage
	/fork
		/afe89fsnlvms256d 

	The Forks storage contains all competiting blocks files. They are name as they was named in temp storage. 

	[6] The Pending Transaction File or PTX file. 
	/ptx

	This file contains all pending transaction which have been first validated by the node, and will be add to future block during mining
	proccess. 

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
															How forking block are treat? How virtualisation works?
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_

	When a series of block is received, a Virtual UTXO Set file is created. During last step validation ( verifying block transactions), we first update virtual 
	utxo set of every wallet mentionned (so appending if not existing in virtual utxo set). 
	Then, we update miner utxo. 
	Finally, we verify each transaction in ascending order and update at same time virtual utxos.
	If a block is not valid, virtual utxo set file is deleted. 
	At end, if series of block is valid and the series win the run distance, we overwrite utxo set with virtual utxo set data. 
	utxo set is straight forward : it is a series of (puKey+tou+sold). 
	virtual utxo set is struct differently (byteflag+puKey+uindex+tou+sold). the byteflag indicates the utxo condition. if set to 1, it tell that we need to 
	append the utxo (so uindex is not used ) because he is not existing or pointer is missing...  

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
																How contract works? And how it is read ? 
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_

	[1] How to create a smartcontract?

	A smartcontract is a series of opcodes and operands that allow to write, read data from a specific file and perform arithmetics, comparison and
	memory jumps. They are written as a sequence of byte. This works exactly like machine language. But it is not read directly by the CPU. There is
	a fake machine that contains virtual registers, memory, stack ... etc.
	Write the contract and submit it to the blockchain with a CST (CONTRACT-SUBMISSION-TRANSACTION).

	a CST is struct like all other transactions
	(the data is the smartcontract code, the byte ID indicates to validator to perform sc verification ):

	[TX header]
	PuKey Pointer   (4 bytes)
	PrKey Signature (512 bytes)
	TOU             (4 bytes)
	Purishment      (4 bytes)
	Fee             (4 bytes)
	Byte ID         (1 byte )
	[TX data]
	Data Size       (4 bytes)
	Data            (Data Size)

	Validators verify smart contract max limit, then perform the code until the first halting opcode.
	The smartcontract is not valid if its size exceed 32ko and/or if the "first run" gas out.
	So you need to pay 2 things for developping smartcontract in the genesis chain:
	* the gas of the first run (including finding the main entry gas cost)
	* the gas of the smart contract storage file creation (which is named as the byte position of sc in the blockchain in sc folder)

	[2] How the Smart Contract is used during the blockchain time ?

	A Smart Contract is struct in a specific way, here it is:
	entries length (4 bytes)
	entries        (entries length)
	smart contract code (the "real entry")

	Entries are address to code. They are  general function in the smart contract that can be called by people using
	the blockchain with specific transaction type : CRT transaction (CONTRACT-REQUEST-TRANSACTION)

	As CST, CRT struct is the same but data is built diffently:
	Smart Contract pointer    (4 bytes)
		[*] Push  Operations  (4 bytes) -> repeated a specific amount of time determined by validator with data size
	Smart Contract Entry Jump (4 bytes)

	In depth, you can push immediate value to the stack as arguments before jumping to the smart contract code entry. Most of the time
	arguments will be value, pukey pointer and signature...

	Validator will perform as always some verifications, if the data dont exceed 32ko and if you have suffisant sold to perform
	the push operations, if the entry jump point is not above entries length and finally if you have suffisant sold to perform
	the code. Then, validators perform the code at entry until the first halting opcode.

	So, you need to pay some stuff to use a smart contract :
	* the gas for the push operations
	* the gas for the entry verification
	* the gas for the smart contract usage

	And thats it!

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
																		Virtual Machine
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
																			Issues 
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_

[0] Token Of Uniqueness Issue

TOU is a costless way to avoid double spending problem. The main counterpart is that miner has to possess all of your ptx to assemble them correctly. 
eg : You do 3 transaction in a short time and spread them. They are respectively TOU 1,2 and 3. 
	 A miner cannot add second transaction in block if he don't have first transaction. Same with third. 

[1] Virtual UTXO pattern searching Issue

Actual Virtual UTXO build is slow and inneficient:

[1.a] Virtual UTXO pattern searching Issue

When we want to validate a TX which check if sold at utxop is greater or lower than specific value. Can also mentionned zeroed utxop then puKey. 
How to get UTXO from (utxop or puKey) efficiently in UTXO Set : if utxop>0 jump x times is efficient. else, just append (create new) with puKey. 

But when it comes to virtual utxo, its different. Virtual UTXO is never more than 4gb i guess ( cause we never accept blocks files higher than 4gb )
we cannot jump. we have to memcmp everything , do pattern searching. Pattern searching is always bad idea. 
a better struct (?): 
	entries(utxop+boff)data(pukey) ???


[2] Current UTXO limitation

First Transaction for a user can be done one time. Then he has to wait the transaction in the blockchain to get his pointer and use his wallet.
Transaction points to bytes in utxo set. But i guess, they ' re no workaround, thats good.  
The UTXO backward machine (needed for proccess blocks files with starting index lower than hghest official ) : Fucking slow.


