/*
INSTRUCTIONS A IMPLEMANTER: 
LIRE LE STORAGE D'AUTRES SMARTCONTRACT.
LIRE DES BLOCS. ( TXS, ETC. ) LIRE DES UTXOS (ETC.) 

*/

#include "vm.h"

#define MEM_SIZE 32000 

unsigned char MEM[MEM_SIZE];
char  storagefPath [250];
/*
		
		   REGS IN THE MEM STRUCTURE :

		   0x00           EAX
		   0x04           EBX
		   0x08           ECX
		   0x0C           EDX
		   0x10           ESP
		   0x14           EBP
		   0x18           ESI
		   0x1C           EDI
		   0x20           EIP
		   0x24           IMR    note : immediate value register to avoid if else condition ... 
		   0x28           EFLAGS note : unused
								 note : FPU STACK IS 32bit (and not 80-bit)
		   0x29           ST0
		   0x2D           ST1
		   0x31           ST2
		   0x35           ST3
		   0x39           ST4
		   0x3D           ST5
		   0x41           ST6
		   0x45           ST7
		   0x49           FFLAGS note : unused

		   0x5D           SC CODE
				   ...
		   0x?            STACK

	   */
const char REGmat[] =
{
	0x00, 0x02, 0x00, // A
	0x08, 0x0A, 0x08, // C
	0x0C, 0x0E, 0x0C, // D
	0x04, 0x06, 0x04, // B
	0x03, 0x12, 0x10, // ah, SP
	0x0B, 0x16, 0x14, // ch, BP
	0x0F, 0x1A, 0x18, // dh , SI
	0x07, 0x1E, 0x1C  // bh, DI

};


const char SIBID []=
{
	0x00, //EAX
	0x08, //ECX
	0x0C, //EDX
	0x04, //EBX
	0xFF, //illegal
	0x14, //EBP
	0x18, //ESI
	0x1C  //EDI
};



/*__________________________ OPERATIONS MAPPING __________________________*/
/*               HAS BEEN AUTOGENERATED . 40 MNEMONICS. v1.0 .            */
/*                        see vm opcode 1. txt                            */

const char OPMAP[] =
{

0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 
3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 
6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 
9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 12, 12, 11, 11, 12, 
12, 13, 13, 14, 14, 13, 13, 14, 14, 15, 15, 16, 16, 15, 15, 16, 16, 17, 17, 
18, 18, 17, 17, 18, 18, 19, 19, 20, 20, 19, 19, 20, 20, 21, 21, 22, 22, 21, 
21, 22, 22, 23, 23, 24, 24, 23, 23, 24, 24, 25, 25, 26, 26, 25, 25, 26, 26, 
27, 27, 28, 28, 27, 27, 28, 28, 29, 29, 30, 30, 29, 29, 30, 30, 31, 31, 32, 
33, 31, 31, 34, 35, 36, 37, 38, 39, 40, 41, 255, 255, 255, 255, 255, 255, 
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 
255, 255, 255, 255, 255, 255, 255, 255

};



const char OPNUM[] =
{

3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0

};

const char GASMAP []
{

10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0, 0, 10, 10, 
0, 0, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,


};

void TestVM() 
{
	FILE* f = fopen("C:\\Users\\Gaël\\Pictures\\genesisvm", "rb");
	
	if (f == NULL) { return; } // throw error if cannot read
	fseek(f, 0, SEEK_END);
	uint32_t lSize = ftell(f);
	rewind(f);

	unsigned char * fdata = (unsigned char *)malloc(lSize);
	fread(fdata, 1, lSize, f);
	
	// get number of entries 
	/**/
	uint32_t entriesnum = BytesToUint(fdata); 
	if (entriesnum == 0)
		return; //NO ENTRY IS NOT ALLOWED
	
	unsigned char * tdata = (unsigned char *)malloc(lSize - (entriesnum * 4) - 4);
	memcpy(tdata, fdata + (entriesnum * 4) + 4, lSize - (entriesnum * 4) - 4);
	InitVM(tdata, lSize - (entriesnum * 4) - 4);
	
	RunVM(0, MAX_GAS_SIZE);
	
	PrintReg();
	free(tdata);
	free(fdata);
}

bool LoadContract( uint32_t bIndex, uint32_t TxIndex, bool _newcontract) 
{
	// craft & verify storage path 
	unsigned char buffer[8];
	memcpy(buffer, &bIndex, 4); 
	memcpy(buffer+4, &TxIndex, 4);
	Sha256.init();
	Sha256.write((char*)buffer, 8);
	GetHashString(Sha256.result(), storagefPath);
	std::ostringstream s;

	if (_newcontract) // destination is different when loading from new contract
		s << "sc\\tmp\\" << storagefPath;
	else
		s << "sc\\" << storagefPath;

	std::string ss = s.str();
	strcpy(storagefPath, ss.c_str());

	FILE* f = fopen(storagefPath, "rb");
	if (f == NULL) { return false; } // contract storage not existing 

	// INIT  VM
	fseek(f, 0, SEEK_END);
	uint32_t lSize = ftell(f);
	rewind(f);

	unsigned char * fdata = (unsigned char *)malloc(lSize);
	fread(fdata, 1, lSize, f);

	// get number of entries 
	/**/
	uint32_t entriesnum = BytesToUint(fdata);
	if (entriesnum == 0)
		return false; //NO ENTRY IS NOT ALLOWED?

	unsigned char * tdata = (unsigned char *)malloc(lSize - (entriesnum * 4) - 4);
	memcpy(tdata, fdata + (entriesnum * 4) + 4, lSize - (entriesnum * 4) - 4);
	InitVM(tdata, lSize - (entriesnum * 4) - 4);
	free(tdata);
	free(fdata);

	fclose(f);


	return true;
}

bool InitVM(unsigned char * cs, uint32_t length, uint32_t startaddress)
{
	// Init VM with CS Code
	// EIP (0X2) is initialize at 0x5d
	UintToBytes(startaddress, MEM + 0x20);
	// ESP is initialize at MEM + MEM_SIZE
	UintToBytes(MEM_SIZE - 1, MEM + 0x10);
	// Copying code seems not working ...
	memcpy(MEM + 0x5D, cs, length);
	return true;
}


bool RunVMAtPtr(uint32_t memaddr, int gas, int _guserlimit)
{
	UintToBytes(memaddr, MEM + 0x20);
	return RunVM(gas, _guserlimit);
}


bool PushArgument(uint32_t arg)
{
	unsigned char * t = MEM + 0x10;
	int * spaddr = (int*)t;
	*spaddr -= 4;
	memcpy(MEM + BytesToUint(MEM + 0x10), &arg, 4);
	return true;
}

int RunVM(int gas, int _guserlimit) // return gas used.
{

	/*
									ISSUE

			*	SIB MODE + DSP AS BASE IS NOT WORKING
			*	IMMEDIATE IS ALWAYS 32BIT WE DONT USE D-BIT FOR ASSIGN CONSTANT DEPTH. 
				WE COULD USE FIRST REG BIT TO IMPLEMENT IT ( CAUSE WE DONT NEED OPCODE EXTENSION)
			*	MOST OF STUFF DONT IMPLEMENT S-BIT ...
		
	*/
	int i_gas = gas;
	int ctrt = 0;
	FILE* f; 

	while (1)
	{
		// some rough material
		unsigned char * t = MEM + 0x20;
		int * eipaddr = (int*)t;
		t = MEM + 0x10;
		int * spaddr = (int*)t;

		uint32_t bl, op_off, mrr_off, sib_off, disp_off, const_off; // [ IMPROVMENT ] SHOULD BE ONLY ONE INC OFFSET USED
		
		op_off    = 0; // ++ if prefix
		mrr_off   = 1; // ++ if prefix
		sib_off   = 2; // ++ if prefix
		disp_off  = 2; // ++ if prefix, ++ if sib 
		const_off = 2; // ++ if prefix, ++ if sib, ++ if disp


		// [0] first check prefix offset
		// [1] Get OPCODE
		unsigned char  OPCODE = *(MEM + *eipaddr); 
		// default jump if 0.
		bl = 1;

		//  ________________________________________ DECODING ADDRESSING MODE _____________________________________________

		// [1b] 
		// depending of opcode jump
		// [2] GET OPCODE info

		bool s = false;
		bool imm = false;
		bool d = false; // dont needed if one 

		unsigned char * REGADDR, *RMADDR;
		unsigned char * addr1, *addr2;
		REGADDR = NULL;
		RMADDR = NULL;
		addr1 = NULL;
		addr2 = NULL;

		if (OPNUM[OPCODE] > 0)
		{
			 s = (IsBitSet(7, OPCODE));
			 imm = (IsBitSet(5, OPCODE));
			 d = (IsBitSet(6, OPCODE)); // dont needed if one 

			bl = 2;
			unsigned char MODREGXM = *(MEM + *eipaddr + mrr_off);

			unsigned char REG = 0;
			unsigned char MOD = 0;
			unsigned char RM = 0;
			// copying bits
			SetBit(7, IsBitSet(1, MODREGXM), &MOD);
			SetBit(6, IsBitSet(0, MODREGXM), &MOD);

			SetBit(7, IsBitSet(4, MODREGXM), &REG);
			SetBit(6, IsBitSet(3, MODREGXM), &REG);
			SetBit(5, IsBitSet(2, MODREGXM), &REG);

			SetBit(7, IsBitSet(7, MODREGXM), &RM);
			SetBit(6, IsBitSet(6, MODREGXM), &RM);
			SetBit(5, IsBitSet(5, MODREGXM), &RM);

			
			// 16bit mode always false if not 0x66 prefix
			REGADDR = GetREGaddr(REG, s, false);
			RMADDR = GetREGaddr(RM, s, false);

			// CHECK SIB MODE OR DISPONLY MOD
			unsigned char  mod = 0;
			// copying bits
			SetBit(7, IsBitSet(1, MODREGXM), (unsigned char *)&mod);
			SetBit(6, IsBitSet(0, MODREGXM), (unsigned char *)&mod);

			if (mod == 0)
			{
				
				// SIB MODE ( not called CISC for nothing ...) 
				if (RM == 4)
				{
					//std::cout << "detected" << std::endl;
				
					// update offs
					disp_off++;
					const_off++;
					bl++;
					// we update R/M with SIB MODE
					unsigned char SIB = *(MEM + *eipaddr + sib_off);
					unsigned char scale = 0;
					unsigned char index = 0;
					unsigned char base = 0;

					SetBit(7, IsBitSet(1, SIB), &scale);
					SetBit(6, IsBitSet(0, SIB), &scale);

					switch (scale) {
						case 0: scale = 1; break;
						case 1: scale = 2; break;
						case 2: scale = 4; break;
						case 3: scale = 8; break;
					}

					//std::cout << "scale : " << (int)scale << std::endl;
					unsigned char * BASEADDR, * INDEXADDR;

					SetBit(7, IsBitSet(4, SIB), &index);
					SetBit(6, IsBitSet(3, SIB), &index);
					SetBit(5, IsBitSet(2, SIB), &index);

					if (index == 5) // illegal...
						return 0;


					INDEXADDR = MEM + SIBID[index]; // does this scale to intptr ? +4 * sibid?

					SetBit(7, IsBitSet(7, SIB), &base);
					SetBit(6, IsBitSet(6, SIB), &base);
					SetBit(5, IsBitSet(5, SIB), &base);

					
					if (base == 5) // disp as base not working 
					{
						const_off += 4;
						int disp32 = BytesToUint(MEM + *eipaddr + disp_off); 
						BASEADDR = MEM + disp32;
						bl += 4;
					}
					else
					{
						BASEADDR = MEM + SIBID[base];
					}

					RMADDR = MEM + BytesToUint(BASEADDR) + (BytesToUint(INDEXADDR)*scale);

				}
				// 32bit DISP ONLY
				else if (RM == 5)
				{
					//	RMADDR = (unsigned char *) 
					const_off += 4;
					int disp32 = BytesToUint(MEM + *(eipaddr) + disp_off); //*(MEM + *(MEM + 0x20) + disp_off); 
					bl += 4;
					RMADDR = MEM + disp32;
				}
				// INDIRECT
				else
				{
					// can be either 32b or 8 bit. be carefull of this 
					RMADDR = MEM + BytesToUint(RMADDR); 
				}
				// SIB MOD


			}
			if (mod == 1) // probleme is here . RMADDR CAN BE 32bit... 
			{
				// indirect + disp 8 
				// CARE FULL MEM IS32 BIT ... 
				const_off++;
				char disp8 = *(MEM + *(eipaddr) + disp_off); // CAREFULL BECAUSE OF SIB ETC. CONSTANT .ETC
				bl++; 
				RMADDR = MEM + BytesToUint(RMADDR) + disp8;
			}
			if (mod == 2)
			{
				// indirect + disp 32 
				int disp32 = BytesToUint(MEM + *(eipaddr) + disp_off);// *(MEM + *(MEM + 0x20) + disp_off); // !!------------------------------------
				bl += 4;
				const_off++;
				RMADDR = MEM + BytesToUint(RMADDR) + disp32;
			}
			if (d)
			{
				// dest : REG, source : R/M
				addr1 = REGADDR;
				addr2 = RMADDR;
			}
			else
			{
				// dest : R/M, source : REG
				addr2 = REGADDR;
				addr1 = RMADDR;
			}
		
			
			if (imm) // imm is always 32bit ....
			{
				// [the first reg bit should tell if const is one byte or 4 bytes ] 

				addr1 = RMADDR; // does it needed ???--????
				int   imm32 = BytesToUint(MEM + *(eipaddr)+const_off);//(int)*(MEM + *(MEM + 0x20) + const_off);
					//std::cout << imm32 << std::endl;
					// short imm16 = *(MEM + *(MEM + 0x20) + 2); no 16bit mode
				memcpy(MEM + 0x24, &imm32, 4);
				// 2 means one operand. 3 means 2 operands. 
				if (OPNUM[OPCODE] == 2)
					addr1 = MEM + 0x24;
				else
					addr2 = MEM + 0x24; 
				
				bl += 4;

				/*
				//std::cout << "is imm" << std::endl;
				if ( !s )
				{
					char  imm8 = *(MEM + *(eipaddr) + const_off);
					*(MEM + 0x24) = imm8; 
					if (OPNUM[OPCODE] == 2)
						addr1 = MEM + 0x24;
					else 
						addr2 = MEM + 0x24;
					bl++;
				}
				else
				{
					int   imm32 = BytesToUint(MEM + *(eipaddr) + const_off);//(int)*(MEM + *(MEM + 0x20) + const_off);
					//std::cout << imm32 << std::endl;
					// short imm16 = *(MEM + *(MEM + 0x20) + 2); no 16bit mode
					memcpy(MEM + 0x24, &imm32, 4);
					if (OPNUM[OPCODE] == 2)
						addr1 = MEM + 0x24;
					else
						addr2 = MEM + 0x24;
					bl += 4;
				}
				*/

			}
		}
		
		int * caddr1 = reinterpret_cast<int*>(addr1);
		int * caddr2 = reinterpret_cast<int*>(addr2);
		
		//  ___________________________________________ (-_-) _____________________________________________

		// RUN INSTRUCTION ( BY OPCODE MAP (16*16 mat) )( and get INSTRUCTION IDENTIFIER ) 
		char OPID = OPMAP[OPCODE];
		// Update EIP before jump functions.
		
		// when i inc a int pointer it moves by four
		// eip addr can be use 
		
		*(eipaddr) += bl;
		gas += GASMAP[OPCODE];

		if (gas >= MAX_GAS_SIZE || gas-i_gas >= _guserlimit) {
			return 0;
		}
		// break if gas is above max
		switch (OPID)
		{
			case 0: // ADD 
				if (s) 
					*(caddr1) += *(caddr2);
				else
					*(addr1) += *(addr2);
			break; 
			case 1: // AND 
				if (s)
					*(caddr1) &= *(caddr2);
				else
					*(addr1) &= *(addr2);
			break;
			case 2: // CMP ( it is a substraction and do some stuff ) 
				// WARNING WE JUST USE 
				unsigned char nf;
				int res;
				if (s)
					res = (uint32_t)*(caddr2)-(uint32_t)*(caddr1);
				else
					res = (uint32_t)*(addr2)-(uint32_t)*(addr1);

				if (res > 0) // SET CF
				{
					SetBit(0, true, &nf);
				}
				if (res == 0 ) //SET ZF
				{
					SetBit(6, true, &nf);
				}
				MEM[0x28] = nf;
			break;
			case 3: // MOV
				//std::cout << "moving to " << (addr1 - MEM) << "from " << (addr2 - MEM)<<  std::endl;
				if (s)
					*(caddr1) = *(caddr2);
				else
					*(addr1) = *(addr2);
			break;
			case 4: // OR
				if (s)
					*(caddr1) |= *(caddr2);
				else
					*(addr1) |= *(addr2);
			break;
			case 5: // ROL
				//??????????????
			break;
			case 6: // ROR
				//??????????????
				break;
			case 7: // SHL
				if (s)
					*(caddr1) << *(caddr2);
				else
					*(addr1) << *(addr2);
				break;
			case 8: // SHR
				if (s)
					*(caddr1) >> *(caddr2);
				else
					*(addr1) >> *(addr2);
				break;
			case 9: // SUB
				if (s) 
					*(caddr1) -= *(caddr2);
				else
					*(addr1) -= *(addr2);
			break;
			case 10: // XOR
				if (s)
					*(caddr1) ^= *(caddr2);
				else
					*(addr1) ^= *(addr2);
				break;
			case 11: // DEC
				if (s)
					*caddr1 -= 1; // marche pas car mais le registre en rm 
				else
					*addr1 -= 1;
				break;
			case 12: // INC
				if (s)
					*caddr1 += 1;
				else
					*addr1 += 1;
				break;
			case 13: // DIV
				caddr2 = (int*)MEM;
				if (s)
					*(caddr2) = ((uint32_t)*(caddr1)) / ((uint32_t)*(caddr2));
				else
					*(caddr2) = ((uint32_t)*(addr1)) / ((uint32_t)*(addr2));
				break;

			case 14: // MUL ( result store in eax ). mult by operand 1 
				caddr2 = (int*)MEM;
				if (s)
					*(caddr2) = ((uint32_t)*(caddr1)) * ((uint32_t)*(caddr2));
				else
					*(caddr2) = ((uint32_t)*(addr1)) * ((uint32_t)*(addr2));
				break;

			case 15: // IDIV
				caddr2 = (int*)MEM;
				if (s)
					*(caddr2) /= *(caddr2);
				else
					*(caddr2) /= *(addr1);
				break;

			case 16: // IMUL
				caddr2 = (int*)MEM;
				if (s)
					*(caddr2) *= *(caddr1);
				else
					*(caddr2) *= *(addr1);
				break;

			case 17: // JMP
				UintToBytes(*caddr1, MEM + 0x20);
				break;
			case 18: // NEG
				if (s)
					*(caddr1) *= -1;
				else
					*(addr1) *= -1;
				break;
			case 19: // NOT
				if (s)
					*(caddr1) ^= -1;
				else
					*(addr1) ^= -1;
				break;
				//---------- CONDITIONNAL JUMP-----------
			case 20: // JE
				if (IsBitSet(6, MEM[0x28])) 
					UintToBytes(*(caddr1), MEM + 0x20);
				break;
			case 21: // JA SEEMS INVERT
				if (!IsBitSet(0, MEM[0x28]) && !IsBitSet(6, MEM[0x28]))
					UintToBytes(*(caddr1), MEM + 0x20);
				break;
			case 22: // JAE
				if (!IsBitSet(0, MEM[0x28]) )
					UintToBytes(*(caddr1), MEM + 0x20);
				break;
			case 23: // JB
				if (IsBitSet(0, MEM[0x28]) && !IsBitSet(6, MEM[0x28]))
					UintToBytes(*(caddr1), MEM + 0x20);
				break;
			case 24: // JBE
				if (IsBitSet(0, MEM[0x28]))
					UintToBytes(*(caddr1), MEM + 0x20);
				break;
				// same as last four but signed. NOT IMPLEMENTED.
			case 25: break;
			case 26: break;
			case 27: break;
			case 28: break;

			case 29:  // POP 
				if (s) 
				{
					memcpy(caddr1, MEM + BytesToUint(MEM + 0x10), 4);
					*spaddr +=4; 
				}
				else 
				{
					*(addr1) = *((char*)MEM + *(MEM + 0x10));
					*spaddr++;
				}
				break; 

			case 30:  // PUSH

				if (s)
				{
					*spaddr-=4;
					 memcpy(MEM + BytesToUint(MEM + 0x10), caddr1, 4);
				}
				else
				{
					*spaddr--;
					*((char*)MEM + *(MEM + 0x10)) = *(addr1);
				}
				break;
			case 31:  // CALL  ( push eip, jmp operand ) 
				*spaddr -= 4; 
				*( (int*)MEM + *(MEM + 0x10)) = *(eipaddr);
				UintToBytes(*(caddr1), MEM + 0x20); 

				break;

			case 32:  // RET  ( pop eip )

				*eipaddr = *((int*)MEM + *(MEM + 0x10));
				*spaddr += 4;
				break;
			case 33: // JECXZ 
				if (BytesToUint(MEM + 0x08) == 0) 
				{
					UintToBytes(*(caddr1), MEM + 0x20);
				}
				break; 
			case 34: // POPA  ( pop tout les registres generaux dans cet ordre )  
				     // EDI, ESI, EBP, ESP, EBP, EBX, EDX, ECX, EAX

				memcpy(MEM + 0x1C, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;
				memcpy(MEM + 0x18, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;
				memcpy(MEM + 0x14, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;
				memcpy(MEM + 0x10, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;
				memcpy(MEM + 0x14, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;
				memcpy(MEM + 0x04, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;
				memcpy(MEM + 0x0C, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;
				memcpy(MEM + 0x08, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;
				memcpy(MEM, MEM + BytesToUint(MEM + 0x10), 4);
				*spaddr += 4;

				break;

			case 35: // PUSHA ( pousse tout les registres generaux dans cet ordre )  
				    // EAX, ECX, EDX, EBX, EBP, ESP (original value), EBP, ESI, and EDI

				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM , 4);
				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM + 0x08, 4);
				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM + 0x0C, 4);
				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM + 0x04, 4);
				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM + 0x14, 4);
				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM + 0x10, 4);
				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM + 0x14, 4);
				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM + 0x18, 4);
				*spaddr -= 4;
				memcpy(MEM + BytesToUint(MEM + 0x10), MEM + 0x1C, 4);
				break;

			case 36: // HLT
				return gas;
			//	-_-_-_-_-_-_-_-_-_-_-_-_-_ CUSTOM METHOD -_-_-_-_-_-_-_-_-_-_-_-_-_	\\

			case 37: // VFS -> Verify Signature. Not implemented 
				break;
			case 38: // SHA -> Compute SHA256. EAX: RAM PTR | ECX: Number Of Bytes | EDX: RAM PTR (hash)
				Sha256.init();
				Sha256.write((char*)MEM + BytesToUint(MEM), BytesToUint(MEM+0x08));
				memcpy(MEM + BytesToUint(MEM + 0x0C), Sha256.result(), 32);
				break;

			case 39: // RSA?
				break;
			case 40: // LDF -> Load  Contract storage. EAX: FILE PTR | ECX: Number Of Bytes | EDX: RAM PTR
				f = fopen(storagefPath, "rb");
				if (f == NULL) { return 0; } 
				fseek(f, BytesToUint(MEM), SEEK_SET);
				fread(MEM + BytesToUint(MEM + 0x0C), 1, BytesToUint(MEM + 0x08), f);
				fclose(f);
				break;
			case 41: // STF -> Store Contract storage. EAX: FILE PTR | ECX: Number Of Bytes | EDX: RAM PTR
				f = fopen(storagefPath, "r+b");
				if (f == NULL) return 0;
				fseek(f, BytesToUint(MEM), SEEK_SET);
				fwrite(MEM + BytesToUint(MEM + 0x0C), 1, BytesToUint(MEM + 0x08), f);
				fclose(f);
				break;
		}

		ctrt++;
		
			
	}
	return 0;
}

unsigned char *  GetREGaddr(unsigned char val, bool s, bool b16) 
{

	int x,y;
	x = val * 3;
	if (!s)
		y = 0;
	else {
		if (b16)
			y = 1;
		else
			y = 2;
	}
	//std::cout << "REG at MEM -> " << (int)REGmat[x + y] << std::endl;
	return MEM + REGmat[x + y];

}

void PrintReg()
{

	std::cout << "EAX : " <<(int)BytesToUint(MEM) << std::endl;
	std::cout << "EBX : " << (int)BytesToUint(MEM + 0x04) << std::endl;
	std::cout << "ECX : " << (int)BytesToUint(MEM + 0x08) << std::endl;
	std::cout << "EDX : " << (int)BytesToUint(MEM + 0x0C) << std::endl;

	std::cout << "EBP : " << (int)BytesToUint(MEM + 0x14) << std::endl;
	std::cout << "ESP : " << (int)BytesToUint(MEM + 0x10) << std::endl;

}

void PrintStackRange(int r) 
{

	int div = r / 2;
	int * spaddr =(int *)( MEM + 10 );
	for (int i = -r; i < r; i++ )
		std::cout << "["<< (int*)( *(MEM + 0x10) + i) <<"]: " << *((int*)MEM + *(MEM + 0x10) + i) << std::endl;
}

void PrintTopStack() 
{
	//*( (int*)MEM + *(MEM + 0x10))
	std::cout << "[STACK]: " << *((int*)MEM + *(MEM + 0x10)) << std::endl;
}
void PrintMem(uint32_t add)
{
	std::cout << "[" << add <<"]: " << (int)BytesToUint(MEM + add) << std::endl;

}